## 题意

给定两个字符串 **s` 和 `p`, 判断 p 能否匹配 s, 其中 p 除了小写字母外, 还有如下两种通配符:

1. `?`: 可以匹配任意一个字符;
2. `*`: 可以匹配任意多个字符, 包括空串.

## 解答

使用 DP 求解, 声明一个二维数组 `dp [][]bool` 使用 dp[i][j] 表示 p 的前 i 个字符能否匹配 s 的前 j 个字符. 那么对于每一个 dp[i][j], 都有如下的状态转移过程:

1. **i 和 j 都为 0**, dp[i][j] 为 true;
2. **只有 i 为 0**, dp[i][j] 为 false;
3. **只有 j 为 0**, 当 p 的前 i 个字符能匹配空串时, 需要 p 的第 i 个字符为 `*` 且前 i-1 个字符同样能匹配空串, 即 dp[i][j] = p[i-1]=='*' && dp[i-1][j];
4. **i 和 j 都不为 0**, 这样因为通配符的存在可以分为两种情况处理:
  - 当 **p[i-1] = '\*'** 时, 只需要根据统配的含义, 判断 `dp[i-1][j-1] || dp[i][j-1] || dp[i-1][j]` 即可, 这个表达式包含 '\*' 匹配任意多个字符的所有情况;
  - 当 **p[i-1] = '?'** 时, 判断 `dp[i-1][j-1]`;
  - 当 p[i-1] 为普通字母时, 需要判断当前字符是否相等 `dp[i-1][j-1] && p[i-1] == s[j-1]`.

根据上面的逻辑完成 p 和 s 第遍历后, 直接返回 dp[len(p)][len(s)] 即可.