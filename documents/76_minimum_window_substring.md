## 题意

给定两个字符串 `s` 和 `t`, 找出 s 中包含 t 的所有字符的最短子串, 如果不包含这样的子串则返回一个空字符串.

## 解答

这道题使用 DP 的话难度有点大, 可以使用滑动窗口求解.

首先我们使用一个 map `m` 来保存 t 中每一个字符出现的次数, 并使用变量 `cnt` 保存 t 的总字符数, 使用布尔值 `found` 表示有没有找到目标子串, , 声明两个变量 `resultL` 和 `resultR` 来表示结果的左右边界, 并使用 `resultLen` 来保存当前找到子串的最小长度.

我们用两个变量 `left` 和 `right` 来保存窗口的左右边界, 初始值都为 0, 然后向后移动 right:

1. **如果 m 中不存在 s[right] 字符**, 直接跳过这次循环;
2. **如果 m 中存在 s[right] 字符**, 那么首先对 m[s[right]] 进行减 1 操作, 如果 m[s[right]] 此时仍然大于或等于 0, 表示当前窗口相对于 t 仍然有多余字符, 所以对 cnt 也进行减 1 操作, 如果 cnt=0, 那么表示已经找到了包含 t 中所有字符的窗口, 可以把 `found` 变量置成 true.  
  接下来就是向后移动 left, 并且根据 right-left+1 和 resultLen 的关系来决定是否需要更新 resultL 和 resultR. 如果 m 中存在 s[left], 就对 m[s[left]] 进行加 1 操作, 如果此时 m[s[left]] 大于 0, 表示相对于 t 已经出现了多余字符, 这时对 cnt++, 可以继续向后移动 right 了.

最后根据 found 变量的值, 如果为 true 的话就返回 resultL 和 resultR 为边界的子串, 为 false 的话返回空串即可.