## 题意

给定一个字符串 `s` 和一个正则表达式 `p`, 判断 s 是否和 p 匹配, p 中除了小写字母之外, 还包含通配符 `.` 和不定数量标识符 `*`.

## 解答

使用 DP 的方式, 声明一个二维数组 `dp [][]bool`, 每一项 dp[i][j] 表示 p 的前 i 个字符能否匹配 s 的前 j 个字符.

对于每一个 dp[i][j]:

1. **i == 0 && j == 0**, 两个都为空的情况, dp[i][j] = true
2. **仅 i == 0**, 正则表达式为空, dp[i][j] = false
3. **仅 j == 0**, 这里要分两种情况:  
  - 如果 p 的第 i 个字符为 `*`, 那么则需要看 p 的前 i - 2 个字符能不能匹配空串, 即 dp[i][j] = dp[i - 2][0]
  - 如果 p 的第 i 个字符不为 `*`, 则不可能匹配空串, dp[i][j] = false
4. **i, j 都不为 0**, 如果 s 第 i 个字符等于 p 的第 j 个字符或者 p 的第 j 个字符为 `.`, 则 dp[i][j] = dp[i - 1][j - 1]; 如果不符合前面条件, 但是 p 的 第 i 个字符为 `*`, 则分成以下几种情况:
  - 如果 p 的第 i - 1 个字符为 `.`, 则只需要 p 的前 i - 2 个字符能匹配 s 的前 j 个字符的任意长度, 最后的通配符 `.*` 就能匹配剩下的字符.
  - 如果 p 的第 i - 1 个字符等于 s 的第 j 个字符, 那么就用一个变量 k 从 j 往前遍历到 s[k - 1] 不等于 s[j - 1] 的位置, 如果里面有任意一个 dp[i - 2][k] 为 true, 即 p 的前 i - 2 个字符匹配 s 的前 k 个字符, 那么 dp[i][j] 为 true, 否则为 false.
  - 如果不符合上面两个场景, 那么表示 p 的第 i 个和第 i - 1 个字符无法匹配 s 前 j 个字符的尾部内容, 那么 dp[i][j] = dp[i - 2][j]