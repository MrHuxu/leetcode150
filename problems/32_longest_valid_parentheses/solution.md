## 题意

给定一个字符串 `s`, 返回其子串里最长合法括号的长度.

## 解答

依然使用 DP 求解.

声明一个数组 `dp []int` 以 dp[i] 表示包含 s[i] 的子串中最长合法括号的长度, 那么直接遍历字符串, 因为只需要处理 `)`, 所以遍历可以从 1 开始.

对于每一个 dp[i], 因为 dp[i-1] 是表示包含 s[i-1] 的子串中最长合法括号的长度, 那么其对应的左括号应该是在 s[i-1-dp[i-1]] 的位置上, 只有这个位置为 `(`, 我们才需要进行下面的处理:

>  比如 `(()())`, 遍历到 i=5 时, dp[4]=4, i 对应的左括号在 i-1-dp[i-1]=0 的位置上

1. 首先 s[i] 与前面的左括号匹配上了, dp[i] = dp[i-1] + 2
2. 然后如果 dp[i-dp[i]] > 0, 也就是在 i 对应的左括号之前已经有合法括号了, 就累加上这个合法括号的长度, 即 dp[i] += dp[i-dp[i]]

然后根据 dp[i] 的值更新结果并返回.