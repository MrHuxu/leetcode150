## 题意

给定一个正整数 `n`, 返回 n 皇后问题的解的个数.

> 通过 [八皇后问题](https://en.wikipedia.org/wiki/Eight_queens_puzzle) 扩展的 n 皇后问题, 即在一个 n*n 的棋盘上, 摆放 n 个皇后子, 其中任意两个皇后不在同一条 横/竖/斜 线上.

## 解答

这道题使用 DFS 求解.

首先我们证明一个数组 `used []int` 使用 used[i]=j 表示棋盘上的 [i,j] 位置已经放上了皇后. 然后编写一个 `validate` 函数, 来用 used 数组来判断一个位置是否可以放上皇后.

然后在遍历的处理上, 因为不能有任意两个皇后在一个横线上, 那么当我们找到某一行的一个位置可以放上皇后之后, 剩下的位置其实都不用处理了, 直接可以开始下一行的遍历, 那么我们的 dfs 函数完全可以从 0 开始, 并且直接以层为单位的往深遍历.

然后 validate 判断当前位置是否可以放皇后同样可以进行优化, 因为我们的遍历是逐层进行的, 那么对于一次 validate(i,j,used) 的操作, 我们只需要使用小于 i 的那些层来判断 竖/左斜/右斜 的三个方向即可, 对于横向以及大于 i 的层的数据则完全不需要处理.